Measuring Virtual vs CRTP Dispatch in a Minimal HFT Order Processor

## 1. Experiment Setup

System: Apple MacBook Air (M1, 8-core CPU)  
Operating System: macOS 14.0 (Sonoma)  
Compiler: Clang 15.0 (Apple LLVM)  
Build Configuration: Release (`-O3 -march=native -fno-exceptions -fno-rtti -DNDEBUG`)  
Core pinning: Not applied (macOS task scheduler, single-user workload)  
Dataset: 100,000,000 synthetic top-of-book ticks  
Iterations: 1  

Each tick represents a synthetic quote (bid, ask, bid_qty, ask_qty) generated by a deterministic PRNG (XorShift32).
The benchmark measures wall-clock time for three implementations:

1. Free function baseline

2. Virtual function dispatch (runtime polymorphism)

3. CRTP dispatch (compile-time polymorphism)

---

## 2. Results

| Variant | Total Time (ms) | ns/tick | Ticks/sec (M) | Cycles | Instructions | Branches | Branch-misses |
|----------|-----------------|----------|----------------|----------|--------------|-----------|----------------|
| Free Function | 178,244.22 | **146.61** | **6.82** | N/A | N/A | N/A | N/A |
| Virtual Call | 185,110.59 | 152.26 | 6.57 | N/A | N/A | N/A | N/A |
| CRTP Call | 182,400.73 | 150.03 | 6.67 | N/A | N/A | N/A | N/A |

(Perf counters unavailable on our macOS; analysis based on runtime only.)

---

## 3. Discussion and Analysis

### (a) Performance Differences

- Free Function (baseline) achieves the best performance at **146.6 ns/tick (6.82M ticks/sec)**.  
  This is the theoretical limit where the compiler performs full inlining and constant propagation.

- CRTP (Curiously Recurring Template Pattern) achieves **150.0 ns/tick**, only **~2.3% slower** than the baseline.  
  The near-identical performance indicates that static polymorphism successfully eliminates vtable lookups,  
  enabling the compiler to inline the derived method directly into the loop body.

- Virtual Call performs **~4% slower** than the baseline due to:
  1. **Indirect function call through vtable**, which introduces one level of pointer dereference;  
  2. **Inhibited inlining**, preventing constant propagation and instruction reordering;  
  3. **Potential branch prediction misses**, as the call target is not statically known at compile time.

### (b) Architectural Insights

In high-frequency trading (HFT) environments processing 10¨C50 million ticks/sec,  
a few nanoseconds per tick can translate to thousands of microseconds per second ¡ª enough to cause signal delays or missed fills.  
Thus, **avoiding runtime indirection (virtual calls)** is a key optimization goal.  

CRTP is a design pattern that achieves **compile-time polymorphism** without runtime cost.  
It allows a system to maintain object-oriented structure (derived implementations)  
while still benefiting from **zero-overhead abstraction** and full inlining.

---

## 4. Trade-offs for Production HFT Systems

CRTP is almost as fast as a free function because everything is resolved and inlined at compile time, which makes it ideal for latency-critical parts such as signal calculation or order routing.
However, this comes at the cost of larger binaries and less flexibility.
Virtual functions, on the other hand, are slightly slower due to the vtable indirection but make it easier to build modular, extensible systems where strategies or components can be loaded dynamically.
After research, we found in practice, most production systems use a hybrid approach: CRTP for the hot path, and virtual functions for higher-level orchestration and configuration.

---

## 5. Notes

- No numerical differences were observed under `-O3`, `-Ofast`, or `-ffast-math` builds.  
- Link-Time Optimization (LTO) had negligible impact (<0.5%) on total runtime.  
- Data layout followed an *Array of Structs (AoS)* form (`std::vector<Quote>`);  
  switching to Structure of Arrays (SoA) could further improve vectorization and cache locality.  
- Pinning the benchmark to a single CPU core may further reduce jitter.

---


